<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="03de08ac-fd37-4f38-ae33-dc113f4d10c8" name="Changes" comment="">
      <change afterPath="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServerDemo.java" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/main/resources/server.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/build.gradle" beforeDir="false" afterPath="$PROJECT_DIR$/build.gradle" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/db.mv.db" beforeDir="false" afterPath="$PROJECT_DIR$/db.mv.db" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ExternalProjectsData">
    <projectState path="$PROJECT_DIR$">
      <ProjectState />
    </projectState>
  </component>
  <component name="ExternalProjectsManager">
    <system id="GRADLE">
      <state>
        <task path="$PROJECT_DIR$">
          <activation />
        </task>
        <projects_view>
          <tree_state>
            <expand>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
              </path>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
                <item name="Tasks" type="e4a08cd1:TasksNode" />
              </path>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
                <item name="Tasks" type="e4a08cd1:TasksNode" />
                <item name="build" type="c8890929:TasksNode$1" />
              </path>
            </expand>
            <select />
          </tree_state>
        </projects_view>
      </state>
    </system>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="AnnotationType" />
        <option value="JUnit5 Test Class" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="master" />
      </map>
    </option>
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="JsbtTreeLayoutManager">
    <layout place="tools.popupGrunt">
      <scroll-view-position x="0" y="0" />
    </layout>
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 7
}</component>
  <component name="ProjectId" id="2mEYPu3STopufuLXHar9R1qrTau" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "Downloaded.Files.Path.Enabled": "false",
    "Gradle.AccountServiceImplParametrizedTest.executor": "Run",
    "Gradle.Build otus-pro-homeworks.executor": "Run",
    "Gradle.Tests in 'impl'.executor": "Run",
    "Gradle.Tests in 'ru.otus.java.pro.unittests.bank.service.impl'.executor": "Run",
    "Gradle.Upgrade Gradle wrapper.executor": "Run",
    "Gradle.otus-pro-homeworks [:Application.main()].executor": "Run",
    "Gradle.otus-pro-homeworks [:HttpServerDemo.main()].executor": "Run",
    "Gradle.otus-pro-homeworks [:Main.main()].executor": "Run",
    "Gradle.otus-pro-homeworks [:MockChatServer.main()].executor": "Run",
    "Gradle.otus-pro-homeworks [build].executor": "Run",
    "Gradle.otus-pro-homeworks [dependencies].executor": "Run",
    "JUnit.AccountServiceImplParametrizedTest.executor": "Run",
    "JUnit.AccountServiceImplTest.executor": "Run",
    "JUnit.ru.otus.java.pro.unittests.bank.service.impl in otus-pro-homeworks.main.executor": "Run",
    "Repository.Attach.Annotations": "false",
    "Repository.Attach.JavaDocs": "false",
    "Repository.Attach.Sources": "false",
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "SHARE_PROJECT_CONFIGURATION_FILES": "true",
    "com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary": "JUnit5",
    "com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5": "",
    "create.test.in.the.same.root": "true",
    "kotlin-language-version-configured": "true",
    "last_opened_file_path": "C:/Users/xa86/IdeaProjects/learning-project/java-first-project",
    "node.js.detected.package.eslint": "true",
    "node.js.detected.package.tslint": "true",
    "node.js.selected.package.eslint": "(autodetect)",
    "node.js.selected.package.tslint": "(autodetect)",
    "nodejs_package_manager_path": "npm",
    "project.structure.last.edited": "SDKs",
    "project.structure.proportion": "0.15",
    "project.structure.side.proportion": "0.0",
    "settings.editor.selected.configurable": "Console",
    "vue.rearranger.settings.migration": "true"
  },
  "keyToStringList": {
    "DatabaseDriversLRU": [
      "postgresql"
    ]
  }
}]]></component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-pro-homeworks\src\main\test\ru\otus\java\pro\unittests\bank\service\impl" />
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-pro-homeworks\src\main\java\ru\otus\java\pro\unittests\bank" />
    </key>
    <key name="CreateTestDialog.Recents.Supers">
      <recent name="" />
    </key>
    <key name="CreateTestDialog.RecentsKey">
      <recent name="ru.otus.java.pro.unittests.bank.service.impl" />
    </key>
  </component>
  <component name="RunManager" selected="Application.HttpServerDemo">
    <configuration name="HttpServerDemo" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.http.HttpServerDemo" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.http.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.patterns.part2.Main" />
      <module name="otus-pro-homeworks.main" />
      <option name="PROGRAM_PARAMETERS" value="-Dfile.encoding=UTF-8" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.patterns.part2.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="MockChatServer" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.dbinteraction.MockChatServer" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.dbinteraction.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="ru.otus.java.pro.streamapi.Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.streamapi.Main" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.streamapi.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Tests in 'ru.otus.java.pro.unittests.bank.service.impl'" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
      <ExternalSystemSettings>
        <option name="executionName" />
        <option name="externalProjectPath" value="$PROJECT_DIR$" />
        <option name="externalSystemIdString" value="GRADLE" />
        <option name="scriptParameters" value="" />
        <option name="taskDescriptions">
          <list />
        </option>
        <option name="taskNames">
          <list>
            <option value=":test" />
            <option value="--tests" />
            <option value="&quot;ru.otus.java.pro.unittests.bank.service.impl.*&quot;" />
          </list>
        </option>
        <option name="vmOptions" />
      </ExternalSystemSettings>
      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>
      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
      <DebugAllEnabled>false</DebugAllEnabled>
      <RunAsTest>true</RunAsTest>
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Application.HttpServerDemo" />
      <item itemvalue="Application.MockChatServer" />
      <item itemvalue="Application.Main" />
      <item itemvalue="Application.ru.otus.java.pro.streamapi.Main" />
      <item itemvalue="Gradle.Tests in 'ru.otus.java.pro.unittests.bank.service.impl'" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Application.HttpServerDemo" />
        <item itemvalue="Application.MockChatServer" />
        <item itemvalue="Application.Main" />
        <item itemvalue="Gradle.Tests in 'ru.otus.java.pro.unittests.bank.service.impl'" />
        <item itemvalue="Application.ru.otus.java.pro.streamapi.Main" />
      </list>
    </recent_temporary>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9f38398b9061-18abd8497189-intellij.indexing.shared.core-IU-241.14494.240" />
        <option value="bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-IU-241.14494.240" />
      </set>
    </attachedChunks>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="03de08ac-fd37-4f38-ae33-dc113f4d10c8" name="Changes" comment="" />
      <created>1726643186346</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1726643186346</updated>
      <workItem from="1726643187429" duration="738000" />
      <workItem from="1726643970714" duration="3310000" />
      <workItem from="1727240860064" duration="2417000" />
      <workItem from="1729670781657" duration="388000" />
      <workItem from="1731242419581" duration="815000" />
      <workItem from="1731397388336" duration="398000" />
      <workItem from="1731397797630" duration="52000" />
      <workItem from="1731397862883" duration="51000" />
      <workItem from="1731397921534" duration="127000" />
      <workItem from="1733036675617" duration="826000" />
    </task>
    <task id="LOCAL-00001" summary="master-commit">
      <option name="closed" value="true" />
      <created>1726644698594</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1726644698594</updated>
    </task>
    <task id="LOCAL-00002" summary="Homework Reflection API и аннотации">
      <option name="closed" value="true" />
      <created>1726647111288</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1726647111288</updated>
    </task>
    <task id="LOCAL-00003" summary="Homework Reflection API и аннотации v2">
      <option name="closed" value="true" />
      <created>1727241031646</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1727241031646</updated>
    </task>
    <task id="LOCAL-00004" summary="Homework Stream Api v1">
      <option name="closed" value="true" />
      <created>1728549054044</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1728549054044</updated>
    </task>
    <task id="LOCAL-00005" summary="Homework Concurrency v1">
      <option name="closed" value="true" />
      <created>1729674000457</created>
      <option name="number" value="00005" />
      <option name="presentableId" value="LOCAL-00005" />
      <option name="project" value="LOCAL" />
      <updated>1729674000457</updated>
    </task>
    <task id="LOCAL-00006" summary="Homework Patterns part1 v1">
      <option name="closed" value="true" />
      <created>1731396034592</created>
      <option name="number" value="00006" />
      <option name="presentableId" value="LOCAL-00006" />
      <option name="project" value="LOCAL" />
      <updated>1731396034592</updated>
    </task>
    <task id="LOCAL-00007" summary="Homework Patterns part1 v1">
      <option name="closed" value="true" />
      <created>1731566488527</created>
      <option name="number" value="00007" />
      <option name="presentableId" value="LOCAL-00007" />
      <option name="project" value="LOCAL" />
      <updated>1731566488527</updated>
    </task>
    <option name="localTasksCounter" value="8" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="master-commit" />
    <MESSAGE value="Homework Reflection API и аннотации" />
    <MESSAGE value="Homework Reflection API и аннотации v2" />
    <MESSAGE value="Homework Stream Api v1" />
    <MESSAGE value="Homework Concurrency v1" />
    <MESSAGE value="Homework Patterns part1 v1" />
    <option name="LAST_COMMIT_MESSAGE" value="Homework Patterns part1 v1" />
  </component>
  <component name="XSLT-Support.FileAssociations.UIState">
    <expand />
    <select />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="134fca">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServerDemo.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/streamapi/model/Task.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="134fca" />
              <option name="initiateTms" value="1735020137100" />
              <option name="request" value=" &gt; Task :HttpServerDemo.main()&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error parsing request&#10;java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 8&#10;&#9;at ru.otus.java.pro.http.HttpServer.parseRequest(HttpServer.java:121)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:87)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:02:08 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;\" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибки, которые вы видите, указывают на проблемы с разбором HTTP-запроса и обработкой закрытых каналов. Давайте внесем дополнительные улучшения в код, чтобы исправить эти проблемы.&#10;&#10;### Обновленный код&#10;&#10;#### Класс `HttpServer`:&#10;```java&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final Logger logger = LoggerFactory.getLogger(HttpServer.class);&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                if (!socketChannel.isOpen() || !socketChannel.isConnected()) {&#10;                    return;&#10;                }&#10;&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                logger.error(&quot;Error handling read&quot;, e);&#10;                try {&#10;                    socketChannel.close();&#10;                } catch (IOException ex) {&#10;                    logger.error(&quot;Error closing socket channel&quot;, ex);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            if (lines.length &lt; 1) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request&quot;);&#10;            }&#10;&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            if (requestLine.length &lt; 2) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request line&quot;);&#10;            }&#10;&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                if (header.length == 2) {&#10;                    headers.put(header[0], header[1]);&#10;                }&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        parameters.put(keyValue[0], keyValue[1]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing request&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений:&#10;1. **Проверка состояния канала**: Перед чтением данных из канала добавлена проверка, что канал открыт и подключен.&#10;2. **Улучшение разбора запроса**: Добавлены проверки на корректность строки запроса и заголовков. Это предотвращает ошибки при разборе некорректных запросов.&#10;&#10;Эти изменения помогут избежать ошибок `ClosedChannelException` и `ArrayIndexOutOfBoundsException`, улучшив стабильность и надежность вашего HTTP-сервера." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735020156741" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServerDemo.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/streamapi/model/Task.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="1fcee7">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/build.gradle" />
                </list>
              </option>
              <option name="id" value="1fcee7" />
              <option name="initiateTms" value="1735019414830" />
              <option name="request" value=" Давай будем использовать lombok и нужен класс для демонстрации" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для использования Lombok и создания демонстрационного класса, мы добавим Lombok в зависимости вашего проекта и создадим класс `HttpServerDemo` для запуска сервера.&#10;&#10;### Обновленный `build.gradle`:&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'com.h2database:h2:1.4.200'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;    implementation 'org.postgresql:postgresql:42.2.23'&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;}&#10;&#10;tasks.withType(JavaCompile) {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Класс `HttpRequest` с использованием Lombok:&#10;```java&#10;import lombok.Data;&#10;import java.util.Map;&#10;&#10;@Data&#10;public class HttpRequest {&#10;    private String method;&#10;    private String uri;&#10;    private Map&lt;String, String&gt; headers;&#10;    private Map&lt;String, String&gt; parameters;&#10;}&#10;```&#10;&#10;### Класс `HttpServer`:&#10;```java&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;                try {&#10;                    socketChannel.close();&#10;                } catch (IOException ex) {&#10;                    ex.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (!lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                headers.put(header[0], header[1]);&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    parameters.put(keyValue[0], keyValue[1]);&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Класс `HttpServerDemo`:&#10;```java&#10;public class HttpServerDemo {&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServerDemo.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение:&#10;1. **Lombok**: Используется для автоматической генерации геттеров, сеттеров и других методов в классе `HttpRequest`.&#10;2. **HttpServerDemo**: Класс для демонстрации запуска сервера. Он загружает конфигурацию из файла `server.properties` и запускает сервер.&#10;&#10;Теперь у вас есть полноценный HTTP-сервер, который соответствует вашим требованиям и использует Lombok для упрощения кода." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735019434963" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/build.gradle" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="21eae5">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="21eae5" />
              <option name="initiateTms" value="1735020094981" />
              <option name="request" value=" http://localhost:8080/test?param1=value1&amp;param2=value2&#10;2024-12-24 08:58:29 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 08:58:29 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 08:58:29 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 08:58:29 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 08:58:29 ERROR ru.otus.java.pro.http.HttpServer - Error handling read&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:73)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)&#10;2024-12-24 09:00:56 ERROR ru.otus.java.pro.http.HttpServer - Error parsing request&#10;java.lang.ArrayIndexOutOfBoundsException: Index 8 out of bounds for length 8&#10;&#9;at ru.otus.java.pro.http.HttpServer.parseRequest(HttpServer.java:121)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:87)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибки, которые вы видите, указывают на несколько проблем в обработке запросов и чтении данных из сокета. Давайте разберем их и предложим решения.&#10;&#10;### Проблема 1: `ClosedChannelException`&#10;&#10;Эта ошибка возникает, когда канал закрыт, но сервер пытается прочитать из него. Это может произойти, если клиент закрыл соединение до того, как сервер успел обработать запрос.&#10;&#10;### Проблема 2: `ArrayIndexOutOfBoundsException`&#10;&#10;Эта ошибка указывает на то, что при разборе запроса происходит попытка доступа к элементу массива, который не существует. Это может быть вызвано некорректным разбором строк запроса.&#10;&#10;### Решение&#10;&#10;1. **Проверка состояния канала перед чтением**: Убедитесь, что канал открыт и подключен перед попыткой чтения.&#10;2. **Улучшение разбора запроса**: Добавьте дополнительные проверки для предотвращения ошибок при разборе строк запроса.&#10;&#10;### Обновленный код&#10;&#10;#### Класс `HttpServer`:&#10;```java&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final Logger logger = LoggerFactory.getLogger(HttpServer.class);&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                if (!socketChannel.isOpen() || !socketChannel.isConnected()) {&#10;                    return;&#10;                }&#10;&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                logger.error(&quot;Error handling read&quot;, e);&#10;                try {&#10;                    socketChannel.close();&#10;                } catch (IOException ex) {&#10;                    logger.error(&quot;Error closing socket channel&quot;, ex);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            if (lines.length &lt; 1) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request&quot;);&#10;            }&#10;&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            if (requestLine.length &lt; 2) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request line&quot;);&#10;            }&#10;&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                if (header.length == 2) {&#10;                    headers.put(header[0], header[1]);&#10;                }&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        parameters.put(keyValue[0], keyValue[1]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing request&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений:&#10;1. **Проверка состояния канала**: Перед чтением данных из канала добавлена проверка, что канал открыт и подключен.&#10;2. **Улучшение разбора запроса**: Добавлены проверки на корректность строки запроса и заголовков. Это предотвращает ошибки при разборе некорректных запросов.&#10;&#10;Эти изменения помогут избежать ошибок `ClosedChannelException` и `ArrayIndexOutOfBoundsException`, улучшив стабильность и надежность вашего HTTP-сервера." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735020117130" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="998678">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="998678" />
              <option name="initiateTms" value="1735019949523" />
              <option name="request" value=" Напиши какой сделать запрос для теста" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для тестирования вашего HTTP-сервера вы можете использовать различные инструменты, такие как `curl`, Postman или даже простой браузер. Вот несколько примеров запросов, которые вы можете использовать для тестирования:&#10;&#10;### 1. Тестирование с помощью `curl`&#10;&#10;#### Запрос для проверки работы сервера:&#10;```sh&#10;curl -X GET http://localhost:8080/&#10;```&#10;&#10;#### Запрос для проверки остановки сервера:&#10;```sh&#10;curl -X GET http://localhost:8080/shutdown&#10;```&#10;&#10;#### Запрос с заголовками и параметрами:&#10;```sh&#10;curl -X GET &quot;http://localhost:8080/test?param1=value1&amp;param2=value2&quot; -H &quot;Custom-Header: HeaderValue&quot;&#10;```&#10;&#10;### 2. Тестирование с помощью браузера&#10;&#10;#### Запрос для проверки работы сервера:&#10;Откройте браузер и введите в адресной строке:&#10;```&#10;http://localhost:8080/&#10;```&#10;&#10;#### Запрос для проверки остановки сервера:&#10;Откройте браузер и введите в адресной строке:&#10;```&#10;http://localhost:8080/shutdown&#10;```&#10;&#10;### 3. Тестирование с помощью Postman&#10;&#10;1. Откройте Postman.&#10;2. Создайте новый запрос.&#10;3. Выберите метод `GET`.&#10;4. Введите URL `http://localhost:8080/` для проверки работы сервера.&#10;5. Нажмите &quot;Send&quot;.&#10;&#10;Для проверки остановки сервера:&#10;1. Откройте Postman.&#10;2. Создайте новый запрос.&#10;3. Выберите метод `GET`.&#10;4. Введите URL `http://localhost:8080/shutdown`.&#10;5. Нажмите &quot;Send&quot;.&#10;&#10;Для запроса с заголовками и параметрами:&#10;1. Откройте Postman.&#10;2. Создайте новый запрос.&#10;3. Выберите метод `GET`.&#10;4. Введите URL `http://localhost:8080/test?param1=value1&amp;param2=value2`.&#10;5. Перейдите на вкладку &quot;Headers&quot; и добавьте заголовок `Custom-Header` со значением `HeaderValue`.&#10;6. Нажмите &quot;Send&quot;.&#10;&#10;### Пример запроса с использованием Java&#10;&#10;Если вы хотите протестировать сервер программно, вы можете использовать следующий пример на Java:&#10;&#10;```java&#10;import java.io.BufferedReader;&#10;import java.io.InputStreamReader;&#10;import java.net.HttpURLConnection;&#10;import java.net.URL;&#10;&#10;public class HttpClientTest {&#10;    public static void main(String[] args) {&#10;        try {&#10;            URL url = new URL(&quot;http://localhost:8080/&quot;);&#10;            HttpURLConnection connection = (HttpURLConnection) url.openConnection();&#10;            connection.setRequestMethod(&quot;GET&quot;);&#10;&#10;            int responseCode = connection.getResponseCode();&#10;            System.out.println(&quot;Response Code: &quot; + responseCode);&#10;&#10;            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));&#10;            String inputLine;&#10;            StringBuilder response = new StringBuilder();&#10;&#10;            while ((inputLine = in.readLine()) != null) {&#10;                response.append(inputLine);&#10;            }&#10;            in.close();&#10;&#10;            System.out.println(&quot;Response: &quot; + response.toString());&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;Этот пример отправляет GET-запрос на сервер и выводит код ответа и тело ответа в консоль.&#10;&#10;Эти запросы помогут вам проверить, что ваш сервер работает корректно и обрабатывает запросы в соответствии с вашими требованиями." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735019965862" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="bef107">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServerDemo.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="bef107" />
              <option name="initiateTms" value="1735019644108" />
              <option name="request" value=" server.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    На логгер" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для использования логгера вместо `e.printStackTrace()`, мы можем использовать библиотеку SLF4J с реализацией Logback. Это позволит нам более гибко управлять логированием.&#10;&#10;### Обновленный `build.gradle`:&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;tasks.withType(JavaCompile) {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Класс `HttpServer` с использованием логгера:&#10;```java&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final Logger logger = LoggerFactory.getLogger(HttpServer.class);&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                logger.error(&quot;Error handling read&quot;, e);&#10;                try {&#10;                    socketChannel.close();&#10;                } catch (IOException ex) {&#10;                    logger.error(&quot;Error closing socket channel&quot;, ex);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (!lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                headers.put(header[0], header[1]);&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    parameters.put(keyValue[0], keyValue[1]);&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing request&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Класс `HttpServerDemo` с использованием логгера:&#10;```java&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.util.Properties;&#10;&#10;public class HttpServerDemo {&#10;    private static final Logger logger = LoggerFactory.getLogger(HttpServerDemo.class);&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServerDemo.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение:&#10;1. **SLF4J и Logback**: Используются для логирования. SLF4J предоставляет абстракцию для различных логгеров, а Logback является одной из реализаций.&#10;2. **Логирование ошибок**: Вместо `e.printStackTrace()` используется `logger.error()` для логирования ошибок.&#10;&#10;Теперь ваш сервер использует логгер для обработки ошибок, что делает его более профессиональным и удобным для отладки." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735019662579" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServerDemo.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="d1c9f4">
          <value>
            <ChatHistoryModel>
              <option name="id" value="d1c9f4" />
              <option name="initiateTms" value="1735019322596" />
              <option name="request" value=" Реализуйте на java.io HTTP-сервер принимающий и распарсивающий запросы, и возвращающий в ответ или 200 OK если с запросом все хорошо, или 500 Internal Server Error если запрос не получилось обработать.&#10;Требования:&#10;1. Обработка запросов происходит в параллельных потоках&#10;2. Запросы должны быть распарсены в объект типа HttpRequest с полями: http-метод, uri, заголовки, параметры запроса&#10;3. При парсинге не должно содаваться лишних объектов (в т.ч. нельзя постоянно пересоздавать byte[] buffer если будете его использовать) (один из самых важных пунктов задания)&#10;4. Настройки сервера (порт, размера пула потоков) должны лежать в отдельном .properties файле&#10;5. Должна быть возможность принимать запросы любого размера (в разумных пределах, пусть будет до 5 мб)&#10;6. При отправке запроса GET /shutdown на сервер он должен остановить свою работу" />
              <option name="response" value="" />
              <option name="responseDescription" value="&lt;em&gt;Dynamic context. Adding files:&lt;br/&gt;&lt;/em&gt;&lt;em&gt;No extra context to request.&#10;&lt;/em&gt;&lt;em&gt;&#10;&#10;&lt;/em&gt;Для реализации HTTP-сервера, который соответствует вашим требованиям, мы будем использовать Java NIO для асинхронной обработки запросов и пул потоков для параллельной обработки. Мы также будем использовать `java.util.Properties` для загрузки настроек сервера из файла конфигурации. &#10;&#10;Вот пример реализации:&#10;&#10;### Файл конфигурации `server.properties`:&#10;```properties&#10;server.port=8080&#10;server.threadPoolSize=10&#10;```&#10;&#10;### Класс `HttpRequest`:&#10;```java&#10;import java.util.Map;&#10;&#10;public class HttpRequest {&#10;    private String method;&#10;    private String uri;&#10;    private Map&lt;String, String&gt; headers;&#10;    private Map&lt;String, String&gt; parameters;&#10;&#10;    // Getters and setters&#10;    public String getMethod() {&#10;        return method;&#10;    }&#10;&#10;    public void setMethod(String method) {&#10;        this.method = method;&#10;    }&#10;&#10;    public String getUri() {&#10;        return uri;&#10;    }&#10;&#10;    public void setUri(String uri) {&#10;        this.uri = uri;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getHeaders() {&#10;        return headers;&#10;    }&#10;&#10;    public void setHeaders(Map&lt;String, String&gt; headers) {&#10;        this.headers = headers;&#10;    }&#10;&#10;    public Map&lt;String, String&gt; getParameters() {&#10;        return parameters;&#10;    }&#10;&#10;    public void setParameters(Map&lt;String, String&gt; parameters) {&#10;        this.parameters = parameters;&#10;    }&#10;}&#10;```&#10;&#10;### Класс `HttpServer`:&#10;```java&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;                try {&#10;                    socketChannel.close();&#10;                } catch (IOException ex) {&#10;                    ex.printStackTrace();&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (!lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                headers.put(header[0], header[1]);&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    parameters.put(keyValue[0], keyValue[1]);&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение:&#10;1. **Конфигурация сервера**: Параметры сервера загружаются из файла `server.properties`.&#10;2. **Асинхронная обработка**: Используется `Selector` и `ServerSocketChannel` для асинхронного приема соединений.&#10;3. **Пул потоков**: Для обработки запросов используется пул потоков.&#10;4. **Парсинг запросов**: Запросы парсятся в объект `HttpRequest`.&#10;5. **Ограничение размера запроса**: Установлено ограничение на размер запроса в 5 МБ.&#10;6. **Завершение работы сервера**: При получении запроса `GET /shutdown` сервер завершает свою работу.&#10;&#10;Этот пример демонстрирует основные принципы, которые можно расширить и улучшить в зависимости от конкретных требований и условий эксплуатации." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735019347902" />
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="e145e8">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="e145e8" />
              <option name="initiateTms" value="1735020301188" />
              <option name="request" value=" http://localhost:8080/test?param1=value1&amp;param2=value2&#10;java.nio.channels.ClosedChannelException: null&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.ensureOpenAndConnected(SocketChannelImpl.java:215)&#10;&#9;at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:403)&#10;&#9;at ru.otus.java.pro.http.HttpServer.lambda$handleRead$0(HttpServer.java:77)&#10;&#9;at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:539)&#10;&#9;at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:833)" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибки `ClosedChannelException` указывают на то, что канал был закрыт до того, как сервер успел обработать запрос. Это может произойти по нескольким причинам, включая проблемы с клиентом, который закрыл соединение, или ошибки в обработке сервера.&#10;&#10;Давайте добавим дополнительные проверки и улучшения для обработки закрытых каналов и корректного разбора запросов.&#10;&#10;### Обновленный код&#10;&#10;#### Класс `HttpServer`:&#10;```java&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;public class HttpServer {&#10;    private static final Logger logger = LoggerFactory.getLogger(HttpServer.class);&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                if (!socketChannel.isOpen() || !socketChannel.isConnected()) {&#10;                    return;&#10;                }&#10;&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                logger.error(&quot;Error handling read&quot;, e);&#10;                try {&#10;                    if (socketChannel.isOpen()) {&#10;                        socketChannel.close();&#10;                    }&#10;                } catch (IOException ex) {&#10;                    logger.error(&quot;Error closing socket channel&quot;, ex);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            if (lines.length &lt; 1) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request&quot;);&#10;            }&#10;&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            if (requestLine.length &lt; 2) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request line&quot;);&#10;            }&#10;&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                if (header.length == 2) {&#10;                    headers.put(header[0], header[1]);&#10;                }&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        parameters.put(keyValue[0], keyValue[1]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Error parsing request&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            logger.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений:&#10;1. **Проверка состояния канала**: Перед чтением данных из канала добавлена проверка, что канал открыт и подключен.&#10;2. **Закрытие канала**: Добавлена проверка, что канал открыт перед его закрытием в блоке `catch`.&#10;3. **Улучшение разбора запроса**: Добавлены проверки на корректность строки запроса и заголовков. Это предотвращает ошибки при разборе некорректных запросов.&#10;&#10;Эти изменения помогут избежать ошибок `ClosedChannelException` и улучшат стабильность и надежность вашего HTTP-сервера." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735020321667" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="e8334c">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
              <option name="id" value="e8334c" />
              <option name="initiateTms" value="1735020379394" />
              <option name="request" value=" Используй @Slf4j" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте обновим код, чтобы использовать аннотацию `@Slf4j` для логирования. Это упростит использование логгера и сделает код более читаемым.&#10;&#10;### Обновленный код&#10;&#10;#### Класс `HttpServer`:&#10;```java&#10;package ru.otus.java.pro.http;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.nio.ByteBuffer;&#10;import java.nio.channels.SelectionKey;&#10;import java.nio.channels.Selector;&#10;import java.nio.channels.ServerSocketChannel;&#10;import java.nio.channels.SocketChannel;&#10;import java.util.HashMap;&#10;import java.util.Iterator;&#10;import java.util.Map;&#10;import java.util.Properties;&#10;import java.util.concurrent.ExecutorService;&#10;import java.util.concurrent.Executors;&#10;&#10;@Slf4j&#10;public class HttpServer {&#10;    private static final int BUFFER_SIZE = 8192;&#10;    private static final int MAX_REQUEST_SIZE = 5 * 1024 * 1024; // 5 MB&#10;    private final int port;&#10;    private final ExecutorService threadPool;&#10;    private volatile boolean running = true;&#10;&#10;    public HttpServer(int port, int threadPoolSize) {&#10;        this.port = port;&#10;        this.threadPool = Executors.newFixedThreadPool(threadPoolSize);&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        Selector selector = Selector.open();&#10;        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();&#10;        serverSocketChannel.bind(new InetSocketAddress(port));&#10;        serverSocketChannel.configureBlocking(false);&#10;        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);&#10;&#10;        while (running) {&#10;            selector.select();&#10;            Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();&#10;            while (keyIterator.hasNext()) {&#10;                SelectionKey key = keyIterator.next();&#10;                keyIterator.remove();&#10;&#10;                if (key.isAcceptable()) {&#10;                    handleAccept(key);&#10;                } else if (key.isReadable()) {&#10;                    handleRead(key);&#10;                }&#10;            }&#10;        }&#10;&#10;        serverSocketChannel.close();&#10;        selector.close();&#10;        threadPool.shutdown();&#10;    }&#10;&#10;    private void handleAccept(SelectionKey key) throws IOException {&#10;        ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();&#10;        SocketChannel socketChannel = serverSocketChannel.accept();&#10;        socketChannel.configureBlocking(false);&#10;        socketChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(BUFFER_SIZE));&#10;    }&#10;&#10;    private void handleRead(SelectionKey key) {&#10;        SocketChannel socketChannel = (SocketChannel) key.channel();&#10;        ByteBuffer buffer = (ByteBuffer) key.attachment();&#10;        threadPool.submit(() -&gt; {&#10;            try {&#10;                if (!socketChannel.isOpen() || !socketChannel.isConnected()) {&#10;                    return;&#10;                }&#10;&#10;                int bytesRead = socketChannel.read(buffer);&#10;                if (bytesRead == -1) {&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; MAX_REQUEST_SIZE) {&#10;                    sendResponse(socketChannel, &quot;HTTP/1.1 413 Payload Too Large\r\n\r\n&quot;);&#10;                    socketChannel.close();&#10;                    return;&#10;                }&#10;&#10;                if (buffer.position() &gt; 0 &amp;&amp; buffer.get(buffer.position() - 1) == '\n') {&#10;                    buffer.flip();&#10;                    HttpRequest request = parseRequest(buffer);&#10;                    if (request != null) {&#10;                        if (&quot;/shutdown&quot;.equals(request.getUri()) &amp;&amp; &quot;GET&quot;.equals(request.getMethod())) {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\nServer is shutting down.&quot;);&#10;                            running = false;&#10;                        } else {&#10;                            sendResponse(socketChannel, &quot;HTTP/1.1 200 OK\r\n\r\n&quot;);&#10;                        }&#10;                    } else {&#10;                        sendResponse(socketChannel, &quot;HTTP/1.1 500 Internal Server Error\r\n\r\n&quot;);&#10;                    }&#10;                    socketChannel.close();&#10;                }&#10;            } catch (IOException e) {&#10;                log.error(&quot;Error handling read&quot;, e);&#10;                try {&#10;                    if (socketChannel.isOpen()) {&#10;                        socketChannel.close();&#10;                    }&#10;                } catch (IOException ex) {&#10;                    log.error(&quot;Error closing socket channel&quot;, ex);&#10;                }&#10;            }&#10;        });&#10;    }&#10;&#10;    private HttpRequest parseRequest(ByteBuffer buffer) {&#10;        try {&#10;            String requestString = new String(buffer.array(), 0, buffer.limit());&#10;            String[] lines = requestString.split(&quot;\r\n&quot;);&#10;            if (lines.length &lt; 1) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request&quot;);&#10;            }&#10;&#10;            String[] requestLine = lines[0].split(&quot; &quot;);&#10;            if (requestLine.length &lt; 2) {&#10;                throw new IllegalArgumentException(&quot;Invalid HTTP request line&quot;);&#10;            }&#10;&#10;            String method = requestLine[0];&#10;            String uri = requestLine[1];&#10;&#10;            Map&lt;String, String&gt; headers = new HashMap&lt;&gt;();&#10;            int i = 1;&#10;            while (i &lt; lines.length &amp;&amp; !lines[i].isEmpty()) {&#10;                String[] header = lines[i].split(&quot;: &quot;);&#10;                if (header.length == 2) {&#10;                    headers.put(header[0], header[1]);&#10;                }&#10;                i++;&#10;            }&#10;&#10;            Map&lt;String, String&gt; parameters = new HashMap&lt;&gt;();&#10;            if (uri.contains(&quot;?&quot;)) {&#10;                String[] uriParts = uri.split(&quot;\\?&quot;);&#10;                uri = uriParts[0];&#10;                String[] params = uriParts[1].split(&quot;&amp;&quot;);&#10;                for (String param : params) {&#10;                    String[] keyValue = param.split(&quot;=&quot;);&#10;                    if (keyValue.length == 2) {&#10;                        parameters.put(keyValue[0], keyValue[1]);&#10;                    }&#10;                }&#10;            }&#10;&#10;            HttpRequest request = new HttpRequest();&#10;            request.setMethod(method);&#10;            request.setUri(uri);&#10;            request.setHeaders(headers);&#10;            request.setParameters(parameters);&#10;&#10;            return request;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Error parsing request&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private void sendResponse(SocketChannel socketChannel, String response) throws IOException {&#10;        ByteBuffer buffer = ByteBuffer.wrap(response.getBytes());&#10;        while (buffer.hasRemaining()) {&#10;            socketChannel.write(buffer);&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            Properties properties = new Properties();&#10;            properties.load(HttpServer.class.getClassLoader().getResourceAsStream(&quot;server.properties&quot;));&#10;&#10;            int port = Integer.parseInt(properties.getProperty(&quot;server.port&quot;));&#10;            int threadPoolSize = Integer.parseInt(properties.getProperty(&quot;server.threadPoolSize&quot;));&#10;&#10;            HttpServer server = new HttpServer(port, threadPoolSize);&#10;            server.start();&#10;        } catch (IOException e) {&#10;            log.error(&quot;Error starting server&quot;, e);&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений:&#10;1. **Использование аннотации `@Slf4j`**: Аннотация `@Slf4j` добавлена в класс `HttpServer`, что позволяет использовать логгер `log` без явного объявления.&#10;2. **Логирование**: Все вызовы логгера теперь используют `log`, предоставленный аннотацией `@Slf4j`.&#10;&#10;Эти изменения делают код более чистым и удобным для чтения, а также упрощают использование логгирования в вашем проекте." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1735020401184" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpServer.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/http/HttpRequest.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>