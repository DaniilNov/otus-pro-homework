<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="03de08ac-fd37-4f38-ae33-dc113f4d10c8" name="Changes" comment="">
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="ExternalProjectsData">
    <projectState path="$PROJECT_DIR$">
      <ProjectState />
    </projectState>
  </component>
  <component name="ExternalProjectsManager">
    <system id="GRADLE">
      <state>
        <task path="$PROJECT_DIR$">
          <activation />
        </task>
        <projects_view>
          <tree_state>
            <expand>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
              </path>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
                <item name="Tasks" type="e4a08cd1:TasksNode" />
              </path>
              <path>
                <item name="" type="6a2764b6:ExternalProjectsStructure$RootNode" />
                <item name="otus-pro-homeworks" type="f1a62948:ProjectNode" />
                <item name="Tasks" type="e4a08cd1:TasksNode" />
                <item name="build" type="c8890929:TasksNode$1" />
              </path>
            </expand>
            <select />
          </tree_state>
        </projects_view>
      </state>
    </system>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="AnnotationType" />
        <option value="JUnit5 Test Class" />
        <option value="Class" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_BRANCH_BY_REPOSITORY">
      <map>
        <entry key="$PROJECT_DIR$" value="master" />
      </map>
    </option>
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 7
}</component>
  <component name="ProjectId" id="2mEYPu3STopufuLXHar9R1qrTau" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;Gradle.AccountServiceImplParametrizedTest.executor&quot;: &quot;Run&quot;,
    &quot;Gradle.Build otus-pro-homeworks.executor&quot;: &quot;Run&quot;,
    &quot;Gradle.Tests in 'impl'.executor&quot;: &quot;Run&quot;,
    &quot;Gradle.Tests in 'ru.otus.java.pro.unittests.bank.service.impl'.executor&quot;: &quot;Run&quot;,
    &quot;Gradle.Upgrade Gradle wrapper.executor&quot;: &quot;Run&quot;,
    &quot;Gradle.otus-pro-homeworks [:Application.main()].executor&quot;: &quot;Run&quot;,
    &quot;Gradle.otus-pro-homeworks [:Main.main()].executor&quot;: &quot;Run&quot;,
    &quot;Gradle.otus-pro-homeworks [build].executor&quot;: &quot;Run&quot;,
    &quot;Gradle.otus-pro-homeworks [dependencies].executor&quot;: &quot;Run&quot;,
    &quot;JUnit.AccountServiceImplParametrizedTest.executor&quot;: &quot;Run&quot;,
    &quot;JUnit.AccountServiceImplTest.executor&quot;: &quot;Run&quot;,
    &quot;JUnit.ru.otus.java.pro.unittests.bank.service.impl in otus-pro-homeworks.main.executor&quot;: &quot;Run&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
    &quot;com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrary&quot;: &quot;JUnit5&quot;,
    &quot;com.intellij.testIntegration.createTest.CreateTestDialog.defaultLibrarySuperClass.JUnit5&quot;: &quot;&quot;,
    &quot;create.test.in.the.same.root&quot;: &quot;true&quot;,
    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/Users/xa86/IdeaProjects/learning-project/otus-pro-homeworks/src/main/test/ru/otus/java/pro/unittests/bank/service/impl&quot;,
    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
    &quot;project.structure.last.edited&quot;: &quot;SDKs&quot;,
    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,
    &quot;project.structure.side.proportion&quot;: &quot;0.0&quot;,
    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,
    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
  }
}</component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-pro-homeworks\src\main\test\ru\otus\java\pro\unittests\bank\service\impl" />
      <recent name="C:\Users\xa86\IdeaProjects\learning-project\otus-pro-homeworks\src\main\java\ru\otus\java\pro\unittests\bank" />
    </key>
    <key name="CreateTestDialog.Recents.Supers">
      <recent name="" />
    </key>
    <key name="CreateTestDialog.RecentsKey">
      <recent name="ru.otus.java.pro.unittests.bank.service.impl" />
    </key>
  </component>
  <component name="RunManager" selected="Application.ru.otus.java.pro.concurrency.Application">
    <configuration name="Application" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.reflection.Application" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.reflection.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.unittests.bank.Main" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.unittests.bank.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="ru.otus.java.pro.concurrency.Application" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.concurrency.Application" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.concurrency.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="ru.otus.java.pro.streamapi.Main" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="ru.otus.java.pro.streamapi.Main" />
      <module name="otus-pro-homeworks.main" />
      <extension name="coverage">
        <pattern>
          <option name="PATTERN" value="ru.otus.java.pro.streamapi.*" />
          <option name="ENABLED" value="true" />
        </pattern>
      </extension>
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="Tests in 'ru.otus.java.pro.unittests.bank.service.impl'" type="GradleRunConfiguration" factoryName="Gradle" temporary="true">
      <ExternalSystemSettings>
        <option name="executionName" />
        <option name="externalProjectPath" value="$PROJECT_DIR$" />
        <option name="externalSystemIdString" value="GRADLE" />
        <option name="scriptParameters" value="" />
        <option name="taskDescriptions">
          <list />
        </option>
        <option name="taskNames">
          <list>
            <option value=":test" />
            <option value="--tests" />
            <option value="&quot;ru.otus.java.pro.unittests.bank.service.impl.*&quot;" />
          </list>
        </option>
        <option name="vmOptions" />
      </ExternalSystemSettings>
      <ExternalSystemDebugServerProcess>false</ExternalSystemDebugServerProcess>
      <ExternalSystemReattachDebugProcess>true</ExternalSystemReattachDebugProcess>
      <DebugAllEnabled>false</DebugAllEnabled>
      <RunAsTest>true</RunAsTest>
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="Application.ru.otus.java.pro.concurrency.Application" />
        <item itemvalue="Application.ru.otus.java.pro.streamapi.Main" />
        <item itemvalue="Application.Application" />
        <item itemvalue="Gradle.Tests in 'ru.otus.java.pro.unittests.bank.service.impl'" />
        <item itemvalue="Application.Main" />
      </list>
    </recent_temporary>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9f38398b9061-18abd8497189-intellij.indexing.shared.core-IU-241.14494.240" />
        <option value="bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-IU-241.14494.240" />
      </set>
    </attachedChunks>
  </component>
  <component name="SpellCheckerSettings" RuntimeDictionaries="0" Folders="0" CustomDictionaries="0" DefaultDictionary="application-level" UseSingleDictionary="true" transferred="true" />
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="03de08ac-fd37-4f38-ae33-dc113f4d10c8" name="Changes" comment="" />
      <created>1726643186346</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1726643186346</updated>
      <workItem from="1726643187429" duration="738000" />
      <workItem from="1726643970714" duration="3310000" />
      <workItem from="1727240860064" duration="2417000" />
      <workItem from="1729670781657" duration="388000" />
      <workItem from="1731242419581" duration="815000" />
    </task>
    <task id="LOCAL-00001" summary="master-commit">
      <option name="closed" value="true" />
      <created>1726644698594</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1726644698594</updated>
    </task>
    <task id="LOCAL-00002" summary="Homework Reflection API и аннотации">
      <option name="closed" value="true" />
      <created>1726647111288</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1726647111288</updated>
    </task>
    <task id="LOCAL-00003" summary="Homework Reflection API и аннотации v2">
      <option name="closed" value="true" />
      <created>1727241031646</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1727241031646</updated>
    </task>
    <task id="LOCAL-00004" summary="Homework Stream Api v1">
      <option name="closed" value="true" />
      <created>1728549054044</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1728549054044</updated>
    </task>
    <task id="LOCAL-00005" summary="Homework Concurrency v1">
      <option name="closed" value="true" />
      <created>1729674000457</created>
      <option name="number" value="00005" />
      <option name="presentableId" value="LOCAL-00005" />
      <option name="project" value="LOCAL" />
      <updated>1729674000457</updated>
    </task>
    <option name="localTasksCounter" value="6" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="master-commit" />
    <MESSAGE value="Homework Reflection API и аннотации" />
    <MESSAGE value="Homework Reflection API и аннотации v2" />
    <MESSAGE value="Homework Stream Api v1" />
    <MESSAGE value="Homework Concurrency v1" />
    <option name="LAST_COMMIT_MESSAGE" value="Homework Concurrency v1" />
  </component>
  <component name="com.github.evgenys91.machinet.common.dslhistory.DslHistoryState">
    <option name="historyDtoById">
      <map>
        <entry key="0d9287">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/build.gradle" />
                  <option value="$PROJECT_DIR$/gradlew.bat" />
                </list>
              </option>
              <option name="id" value="0d9287" />
              <option name="initiateTms" value="1729673295337" />
              <option name="request" value=" Deprecated Gradle features were used in this build, making it incompatible with Gradle 9.0.&#10;You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.&#10;For more on this, please refer to https://docs.gradle.org/8.10.1/userguide/command_line_interface.html#sec:command_line_warnings in the Gradle documentation.&#10;BUILD FAILED in 381ms" />
              <option name="response" value="" />
              <option name="responseDescription" value="Похоже, что ваша сборка использует устаревшие функции Gradle, которые могут быть несовместимы с будущими версиями Gradle, такими как Gradle 9.0. Давайте рассмотрим, как можно выявить и устранить эти предупреждения.&#10;&#10;### Шаги для устранения предупреждений об устаревших функциях Gradle&#10;&#10;1. **Включите режим предупреждений**:&#10;    - Запустите сборку с флагом `--warning-mode all`, чтобы увидеть все предупреждения об устаревших функциях.&#10;    ```sh&#10;    ./gradlew build --warning-mode all&#10;    ```&#10;&#10;2. **Проанализируйте предупреждения**:&#10;    - Просмотрите вывод команды, чтобы определить, какие именно функции или плагины вызывают предупреждения.&#10;&#10;3. **Обновите скрипты сборки**:&#10;    - Внесите изменения в ваши скрипты сборки (`build.gradle` и другие), чтобы устранить предупреждения. Gradle обычно предоставляет альтернативные способы выполнения тех же задач, которые не являются устаревшими.&#10;&#10;### Пример обновления `build.gradle`&#10;&#10;Давайте рассмотрим несколько распространенных устаревших функций и их современные альтернативы.&#10;&#10;#### Устаревшие зависимости&#10;Если вы видите предупреждения об устаревших зависимостях, обновите их до последних версий.&#10;&#10;```gradle&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;```&#10;&#10;#### Устаревшие плагины&#10;Если вы используете устаревшие плагины, обновите их до последних версий или замените на современные альтернативы.&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;    id 'org.springframework.boot' version '3.1.0' // Пример современного плагина&#10;}&#10;```&#10;&#10;#### Устаревшие API&#10;Если вы используете устаревшие API в своих скриптах сборки, замените их на современные альтернативы.&#10;&#10;```gradle&#10;// Устаревший способ&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;&#10;// Современный способ&#10;tasks.named('test') {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Пример обновленного `build.gradle`&#10;Вот пример обновленного файла `build.gradle`, который использует современные функции и зависимости:&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;    id 'org.springframework.boot' version '3.1.0' // Пример современного плагина&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;tasks.named('test') {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Заключение&#10;Запустите сборку с флагом `--warning-mode all`, чтобы увидеть все предупреждения об устаревших функциях. Обновите зависимости, плагины и API в ваших скриптах сборки, чтобы устранить эти предупреждения. Это поможет вам подготовиться к будущим версиям Gradle и избежать проблем с совместимостью." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673309296" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/gradlew.bat" />
                  <option value="$PROJECT_DIR$/build.gradle" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="1963e6">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="1963e6" />
              <option name="initiateTms" value="1729672682289" />
              <option name="request" value=" Зачем в CustomThreadPool поле     private final int capacity;" />
              <option name="response" value="" />
              <option name="responseDescription" value="Поле `private final int capacity;` в классе `CustomThreadPool` представляет собой количество рабочих потоков, которые будут созданы и управляться пулом потоков. Это значение задается при создании экземпляра `CustomThreadPool` и используется для инициализации соответствующего количества потоков `Worker`.&#10;&#10;Однако, если это поле не используется после инициализации потоков в конструкторе, его можно удалить, чтобы упростить код. Давайте рассмотрим, как это сделать.&#10;&#10;### Обновленный CustomThreadPool.java без поля `capacity`&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.Getter;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;@Slf4j&#10;public class CustomThreadPool {&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    @Getter&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;1. **Удаление поля `capacity`**:&#10;    - Поле `capacity` было удалено, так как оно использовалось только в конструкторе для инициализации потоков и не имело дальнейшего применения в классе.&#10;&#10;2. **Конструктор**:&#10;    - Конструктор теперь принимает параметр `capacity` и использует его для создания и запуска указанного количества потоков `Worker`, но не сохраняет это значение в поле класса.&#10;&#10;Эти изменения делают код более чистым и избавляют от ненужного поля, которое не используется после инициализации." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672691259" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="2140d0">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestRunner.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/AfterSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/BeforeSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Disabled.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/exceptions/TestConfigurationException.java" />
                </list>
              </option>
              <option name="id" value="2140d0" />
              <option name="initiateTms" value="1729671642819" />
              <option name="request" value=" Реализуйте собственный пул потоков. Конструктор пула в качестве аргументов ожидает емкость (количество рабочих потоков). После создания объекта пула, он сразу инициализирует и запускает потоки. Внутри пула очередь задач на исполнение организуется через LinkedList. Для передачи пулу новой задачи используется метод execute(Runnable r), указанная задача попадает в очередь исполнения, и как только появится свободный поток – передается на исполнение. Также необходимо реализовать метод shutdown(), после выполнения которого новые задачи больше не принимаются пулом (при попытке добавить задачу можно бросать IllegalStateException), а все потоки для которых больше нет задач завершают свою работу." />
              <option name="response" value="" />
              <option name="responseDescription" value="Для реализации собственного пула потоков в Java, мы будем использовать основные механизмы многопоточности, такие как `Thread`, `Runnable`, `synchronized`, `wait`, и `notifyAll`. Мы создадим класс `CustomThreadPool`, который будет управлять пулом потоков и очередью задач.&#10;&#10;Вот пример реализации:&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private boolean isShutdown;&#10;&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker();&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    public synchronized void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;ThreadPool is shutdown, cannot accept new tasks&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    public synchronized void shutdown() {&#10;        isShutdown = true;&#10;        for (Worker worker : workers) {&#10;            worker.interrupt();&#10;        }&#10;    }&#10;&#10;    private class Worker extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (true) {&#10;                Runnable task;&#10;                synchronized (taskQueue) {&#10;                    while (taskQueue.isEmpty()) {&#10;                        if (isShutdown) {&#10;                            return;&#10;                        }&#10;                        try {&#10;                            taskQueue.wait();&#10;                        } catch (InterruptedException e) {&#10;                            if (isShutdown) {&#10;                                return;&#10;                            }&#10;                        }&#10;                    }&#10;                    task = taskQueue.poll();&#10;                }&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    // Log or handle the exception&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Пример использования CustomThreadPool&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        CustomThreadPool threadPool = new CustomThreadPool(5);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int taskNumber = i;&#10;            threadPool.execute(() -&gt; {&#10;                System.out.println(&quot;Executing task &quot; + taskNumber + &quot; by &quot; + Thread.currentThread().getName());&#10;                try {&#10;                    Thread.sleep(1000); // Simulate task execution&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                }&#10;            });&#10;        }&#10;&#10;        threadPool.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение кода&#10;1. **CustomThreadPool**:&#10;    - Конструктор принимает `capacity` (количество рабочих потоков) и инициализирует их.&#10;    - Метод `execute(Runnable task)` добавляет задачу в очередь задач и уведомляет один из потоков о наличии новой задачи.&#10;    - Метод `shutdown()` устанавливает флаг `isShutdown` в `true` и прерывает все рабочие потоки.&#10;&#10;2. **Worker**:&#10;    - Класс `Worker` расширяет `Thread` и выполняет задачи из очереди.&#10;    - В методе `run()` поток ждет, пока в очереди появится задача, и выполняет её. Если пул завершен, поток завершает свою работу.&#10;&#10;3. **Application**:&#10;    - Пример использования пула потоков. Создаются и добавляются задачи в пул, после чего пул завершается.&#10;&#10;Этот пример демонстрирует базовую реализацию пула потоков. В реальных приложениях могут потребоваться дополнительные функции, такие как обработка исключений, логирование, динамическое изменение количества потоков и т.д." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729671653608" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/exceptions/TestConfigurationException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/BeforeSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/AfterSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestRunner.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Disabled.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestSuite.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="2d265b">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="2d265b" />
              <option name="initiateTms" value="1729672451794" />
              <option name="request" value=" Добавь вот тут через lombok&#10;                    logger.log(Level.SEVERE, &quot;Ошибка при выполнении задачи&quot;, e);" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте используем Lombok для логирования. В Lombok есть аннотация `@Slf4j`, которая автоматически создает логгер для класса, используя библиотеку SLF4J. Это позволяет нам логировать сообщения с различными уровнями логирования.&#10;&#10;### Обновление build.gradle&#10;Если вы еще не добавили зависимости для Lombok и SLF4J, добавьте их в ваш `build.gradle`:&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.Getter;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;@Slf4j&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    @Getter&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    log.error(&quot;Ошибка при выполнении задачи&quot;, e);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;1. **Аннотация `@Slf4j`**:&#10;    - Добавлена аннотация `@Slf4j` для автоматического создания логгера в классах `CustomThreadPool` и `Worker`.&#10;&#10;2. **Логирование исключений**:&#10;    - Использование `log.error(&quot;Ошибка при выполнении задачи&quot;, e)` для логирования исключений с уровнем `ERROR` в классе `Worker`.&#10;&#10;Эти изменения делают код более чистым и удобным для сопровождения, используя возможности Lombok для уменьшения шаблонного кода и улучшения логирования." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672465521" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="3008e1">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="3008e1" />
              <option name="initiateTms" value="1731242536674" />
              <option name="request" value=" При обновлении плагина Plugin &quot;Machinet AI GPT-4 Chat and Unit Tests&quot; was not installed: We are sorry, but we are currently unable to provide our products or services to you due to export control regulations." />
              <option name="response" value="" />
              <option name="responseDescription" value="Сообщение об ошибке, которое вы видите, указывает на то, что плагин &quot;Machinet AI GPT-4 Chat and Unit Tests&quot; не может быть установлен из-за экспортных ограничений. Это может быть связано с географическими ограничениями или другими правовыми ограничениями, наложенными на распространение программного обеспечения.&#10;&#10;### Возможные решения&#10;&#10;1. **Проверьте региональные ограничения**:&#10;    - Убедитесь, что ваш регион не попадает под экспортные ограничения, наложенные на данный плагин. Если это так, возможно, вам придется использовать альтернативные инструменты или плагины.&#10;&#10;2. **Свяжитесь с поддержкой**:&#10;    - Свяжитесь с поддержкой плагина или платформы, на которой вы пытаетесь его установить. Они могут предоставить дополнительную информацию или предложить обходные пути.&#10;&#10;3. **Используйте альтернативные инструменты**:&#10;    - Если плагин недоступен, рассмотрите возможность использования других инструментов для выполнения аналогичных задач. Например, для генерации юнит-тестов и работы с AI можно использовать другие плагины или библиотеки.&#10;&#10;### Альтернативные инструменты для генерации юнит-тестов&#10;&#10;Если вам нужен инструмент для генерации юнит-тестов, вы можете рассмотреть следующие альтернативы:&#10;&#10;1. **JUnit**:&#10;    - JUnit является стандартным фреймворком для тестирования в Java. Вы можете писать тесты вручную или использовать инструменты для автоматической генерации тестов.&#10;&#10;2. **Mockito**:&#10;    - Mockito используется для создания mock-объектов в тестах. Он хорошо интегрируется с JUnit и позволяет легко тестировать взаимодействие между объектами.&#10;&#10;3. **EclEmma**:&#10;    - EclEmma предоставляет возможности для анализа покрытия кода и интегрируется с Eclipse IDE.&#10;&#10;### Пример использования JUnit и Mockito&#10;&#10;Вот пример того, как можно написать юнит-тесты для класса `CustomThreadPool` с использованием JUnit и Mockito:&#10;&#10;1. **Добавьте зависимости в `build.gradle`**:&#10;&#10;```gradle&#10;dependencies {&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;```&#10;&#10;2. **Напишите тесты**:&#10;&#10;Создайте файл `CustomThreadPoolTest.java` и добавьте в него следующие тесты:&#10;&#10;```java&#10;import org.junit.jupiter.api.BeforeEach;&#10;import org.junit.jupiter.api.Test;&#10;import org.mockito.Mockito;&#10;&#10;import java.util.concurrent.atomic.AtomicBoolean;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.Mockito.*;&#10;&#10;class CustomThreadPoolTest {&#10;&#10;    private CustomThreadPool threadPool;&#10;&#10;    @BeforeEach&#10;    void setUp() {&#10;        threadPool = new CustomThreadPool(2);&#10;    }&#10;&#10;    @Test&#10;    void testExecute() {&#10;        AtomicBoolean taskExecuted = new AtomicBoolean(false);&#10;        Runnable task = () -&gt; taskExecuted.set(true);&#10;&#10;        threadPool.execute(task);&#10;&#10;        // Wait a bit to let the task execute&#10;        try {&#10;            Thread.sleep(100);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;&#10;        assertTrue(taskExecuted.get());&#10;    }&#10;&#10;    @Test&#10;    void testShutdown() {&#10;        threadPool.shutdown();&#10;        assertTrue(threadPool.isShutdown());&#10;    }&#10;&#10;    @Test&#10;    void testExecuteAfterShutdown() {&#10;        threadPool.shutdown();&#10;        Runnable task = mock(Runnable.class);&#10;&#10;        assertThrows(IllegalStateException.class, () -&gt; threadPool.execute(task));&#10;        verify(task, never()).run();&#10;    }&#10;}&#10;```&#10;&#10;### Заключение&#10;&#10;Если вы столкнулись с ограничениями при установке плагина, рассмотрите возможность использования альтернативных инструментов и библиотек для выполнения необходимых задач. JUnit и Mockito являются мощными инструментами для написания и выполнения юнит-тестов в Java и могут быть хорошей заменой." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1731242548139" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="398fed">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="398fed" />
              <option name="initiateTms" value="1731242459688" />
              <option name="request" value=" Hello world напиши" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, вот простой пример программы &quot;Hello, World!&quot; на Java:&#10;&#10;### Пример программы &quot;Hello, World!&quot;&#10;&#10;Создайте новый файл `HelloWorld.java` и добавьте в него следующий код:&#10;&#10;```java&#10;public class HelloWorld {&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;Hello, World!&quot;);&#10;    }&#10;}&#10;```&#10;&#10;### Запуск программы&#10;&#10;1. **Компиляция**:&#10;    - Откройте командную строку или терминал.&#10;    - Перейдите в директорию, где находится ваш файл `HelloWorld.java`.&#10;    - Выполните команду для компиляции:&#10;      ```sh&#10;      javac HelloWorld.java&#10;      ```&#10;&#10;2. **Запуск**:&#10;    - После успешной компиляции выполните команду для запуска:&#10;      ```sh&#10;      java HelloWorld&#10;      ```&#10;&#10;Вы должны увидеть следующий вывод:&#10;&#10;```&#10;Hello, World!&#10;```&#10;&#10;### Объяснение кода&#10;&#10;- `public class HelloWorld`: Определяет класс с именем `HelloWorld`.&#10;- `public static void main(String[] args)`: Определяет метод `main`, который является точкой входа для программы.&#10;- `System.out.println(&quot;Hello, World!&quot;);`: Выводит строку &quot;Hello, World!&quot; на консоль.&#10;&#10;Этот пример демонстрирует базовую структуру программы на Java и является отличной отправной точкой для изучения языка." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1731242466525" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="5af5f9">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="5af5f9" />
              <option name="initiateTms" value="1729673700091" />
              <option name="request" value=" C:\Users\xa86\IdeaProjects\learning-project\otus-pro-homeworks\src\main\java\ru\otus\java\pro\concurrency\CustomThreadPool.java:46: error: unmappable character (0x98) for encoding windows-1251&#10;     * �?нициирует упорядоченное завершение работы пула потоков&#10;        ^" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибка `unmappable character (0x98) for encoding windows-1251` указывает на то, что в вашем исходном коде есть символы, которые не могут быть корректно отображены с использованием кодировки `windows-1251`. Это часто происходит, когда исходный код содержит символы, которые не поддерживаются текущей кодировкой.&#10;&#10;### Решение&#10;&#10;1. **Измените кодировку файла на UTF-8**:&#10;    - UTF-8 является более универсальной кодировкой и поддерживает широкий диапазон символов.&#10;&#10;2. **Настройте Gradle для использования UTF-8**:&#10;    - Убедитесь, что Gradle настроен на использование UTF-8 для компиляции.&#10;&#10;### Изменение кодировки файла в IntelliJ IDEA&#10;&#10;1. Откройте файл `CustomThreadPool.java` в IntelliJ IDEA.&#10;2. Перейдите в меню `File` -&gt; `File Encoding`.&#10;3. Выберите `UTF-8` в качестве кодировки для текущего файла.&#10;&#10;### Настройка Gradle для использования UTF-8&#10;&#10;Добавьте следующие строки в ваш `build.gradle`, чтобы убедиться, что Gradle использует UTF-8 для компиляции:&#10;&#10;```gradle&#10;tasks.withType(JavaCompile) {&#10;    options.encoding = 'UTF-8'&#10;}&#10;```&#10;&#10;### Обновленный `build.gradle`&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;tasks.withType(JavaCompile) {&#10;    options.encoding = 'UTF-8'&#10;}&#10;&#10;tasks.named('test') {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Обновленный `CustomThreadPool.java`&#10;&#10;Убедитесь, что все комментарии и строки в файле `CustomThreadPool.java` корректно отображаются в UTF-8:&#10;&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;public class CustomThreadPool {&#10;    private static final Logger log = LoggerFactory.getLogger(CustomThreadPool.class);&#10;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Проверяет, завершен ли пул потоков.&#10;     *&#10;     * @return true, если пул потоков завершен, иначе false&#10;     */&#10;    public boolean isShutdown() {&#10;        return isShutdown;&#10;    }&#10;}&#10;```&#10;&#10;### Заключение&#10;&#10;Изменение кодировки файла на UTF-8 и настройка Gradle для использования UTF-8 должны решить проблему с некорректными символами. Убедитесь, что все файлы вашего проекта используют одну и ту же кодировку, чтобы избежать подобных проблем в будущем." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673713537" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="61547d">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestRunner.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/AfterSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/BeforeSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Disabled.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/exceptions/TestConfigurationException.java" />
                </list>
              </option>
              <option name="id" value="61547d" />
              <option name="initiateTms" value="1729671526724" />
              <option name="request" value=" Как назвать пакет в ru.otus.java.pro где будут задания про многопоточность" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для пакета, который будет содержать задания по многопоточности, вы можете использовать название `concurrency` или `multithreading`. Это будет соответствовать общепринятым практикам именования и сразу укажет на тематику пакета. Таким образом, полный путь к пакету может выглядеть как `ru.otus.java.pro.concurrency` или `ru.otus.java.pro.multithreading`." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729671532168" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/exceptions/TestConfigurationException.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/BeforeSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/AfterSuite.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Test.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestRunner.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/annotations/Disabled.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/reflection/TestSuite.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="6e02ca">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="6e02ca" />
              <option name="initiateTms" value="1729672033922" />
              <option name="request" value=" Вынеси Worker в отдельный класс и добавь через javadoc описание работы" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте вынесем класс `Worker` в отдельный файл и добавим Javadoc комментарии для описания работы пула потоков.&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool is a simple implementation of a thread pool.&#10; * It manages a fixed number of worker threads and a queue of tasks.&#10; * Tasks are executed by the worker threads as they become available.&#10; */&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Constructs a CustomThreadPool with the specified number of worker threads.&#10;     *&#10;     * @param capacity the number of worker threads in the pool&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Submits a task for execution by the thread pool.&#10;     *&#10;     * @param task the task to be executed&#10;     * @throws IllegalStateException if the thread pool is shutdown&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;ThreadPool is shutdown, cannot accept new tasks&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Initiates an orderly shutdown of the thread pool.&#10;     * No new tasks will be accepted, and all worker threads will terminate&#10;     * once all tasks in the queue have been processed.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Checks if the thread pool is shutdown.&#10;     *&#10;     * @return true if the thread pool is shutdown, false otherwise&#10;     */&#10;    public boolean isShutdown() {&#10;        return isShutdown;&#10;    }&#10;}&#10;```&#10;&#10;### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker is a thread that executes tasks from a task queue.&#10; * It is part of a CustomThreadPool and will continue to run until&#10; * the pool is shutdown and the task queue is empty.&#10; */&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    /**&#10;     * Constructs a Worker with the specified task queue and thread pool.&#10;     *&#10;     * @param taskQueue the queue of tasks to be executed&#10;     * @param threadPool the thread pool that this worker belongs to&#10;     */&#10;    public Worker(Queue&lt;Runnable&gt; taskQueue, CustomThreadPool threadPool) {&#10;        this.taskQueue = taskQueue;&#10;        this.threadPool = threadPool;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    // Log or handle the exception&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Пример использования CustomThreadPool&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        CustomThreadPool threadPool = new CustomThreadPool(5);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int taskNumber = i;&#10;            threadPool.execute(() -&gt; {&#10;                System.out.println(&quot;Executing task &quot; + taskNumber + &quot; by &quot; + Thread.currentThread().getName());&#10;                try {&#10;                    Thread.sleep(1000); // Simulate task execution&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                }&#10;            });&#10;        }&#10;&#10;        threadPool.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение кода&#10;1. **CustomThreadPool**:&#10;    - Конструктор принимает `capacity` (количество рабочих потоков) и инициализирует их.&#10;    - Метод `execute(Runnable task)` добавляет задачу в очередь задач и уведомляет один из потоков о наличии новой задачи.&#10;    - Метод `shutdown()` устанавливает флаг `isShutdown` в `true` и уведомляет все потоки, чтобы они могли завершить свою работу.&#10;    - Метод `isShutdown()` возвращает текущее состояние пула потоков.&#10;&#10;2. **Worker**:&#10;    - Класс `Worker` расширяет `Thread` и выполняет задачи из очереди.&#10;    - В методе `run()` поток ждет, пока в очереди появится задача, и выполняет её. Если пул завершен и очередь пуста, поток завершает свою работу.&#10;&#10;3. **Application**:&#10;    - Пример использования пула потоков. Создаются и добавляются задачи в пул, после чего пул завершается.&#10;&#10;Эта версия кода более структурирована и документирована, что делает её легче для понимания и сопровождения." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672057798" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="7527df">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/build.gradle" />
                </list>
              </option>
              <option name="id" value="7527df" />
              <option name="initiateTms" value="1729672278282" />
              <option name="request" value=" add lombok" />
              <option name="response" value="" />
              <option name="responseDescription" value="Lombok — это библиотека, которая помогает уменьшить шаблонный код в Java, предоставляя аннотации для автоматической генерации методов, конструкторов и других элементов. В данном случае, Lombok может быть полезен для автоматической генерации методов `toString`, `equals`, `hashCode`, а также для создания конструкторов и геттеров/сеттеров.&#10;&#10;Для начала, добавим Lombok в зависимости вашего проекта.&#10;&#10;### Обновление build.gradle&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;Теперь давайте добавим Lombok аннотации в наш код.&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.Getter;&#10;import lombok.extern.java.Log;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;@Log&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    @Getter&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.java.Log;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;@Log&#10;@RequiredArgsConstructor&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    log.severe(&quot;Ошибка при выполнении задачи: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение изменений&#10;1. **Аннотация `@Log`**:&#10;    - Добавлена аннотация `@Log` для автоматического создания логгера в классах `CustomThreadPool` и `Worker`.&#10;&#10;2. **Аннотация `@Getter`**:&#10;    - Добавлена аннотация `@Getter` для автоматического создания геттера для поля `isShutdown` в классе `CustomThreadPool`.&#10;&#10;3. **Аннотация `@RequiredArgsConstructor`**:&#10;    - Добавлена аннотация `@RequiredArgsConstructor` в классе `Worker` для автоматического создания конструктора с параметрами для всех `final` полей.&#10;&#10;4. **Логирование исключений**:&#10;    - Использование `log.severe` для логирования исключений в классе `Worker`.&#10;&#10;Эти изменения делают код более чистым и удобным для сопровождения, используя возможности Lombok для уменьшения шаблонного кода." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672294566" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/build.gradle" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="8b2bc8">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="8b2bc8" />
              <option name="initiateTms" value="1729673421560" />
              <option name="request" value=" Давай без lombok" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте уберем Lombok и перепишем классы `CustomThreadPool` и `Worker` без использования Lombok. Мы также обновим `build.gradle`, чтобы убрать зависимости от Lombok.&#10;&#10;### Обновленный `build.gradle`&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;tasks.named('test') {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Обновленный `CustomThreadPool.java`&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;public class CustomThreadPool {&#10;    private static final Logger log = LoggerFactory.getLogger(CustomThreadPool.class);&#10;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Проверяет, завершен ли пул потоков.&#10;     *&#10;     * @return true, если пул потоков завершен, иначе false&#10;     */&#10;    public boolean isShutdown() {&#10;        return isShutdown;&#10;    }&#10;}&#10;```&#10;&#10;### Обновленный `Worker.java`&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;public class Worker extends Thread {&#10;    private static final Logger log = LoggerFactory.getLogger(Worker.class);&#10;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    public Worker(Queue&lt;Runnable&gt; taskQueue, CustomThreadPool threadPool) {&#10;        this.taskQueue = taskQueue;&#10;        this.threadPool = threadPool;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    log.error(&quot;Ошибка при выполнении задачи&quot;, e);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Заключение&#10;Мы убрали Lombok и переписали классы `CustomThreadPool` и `Worker` без использования аннотаций Lombok. Теперь ваш проект не зависит от Lombok, и вы можете продолжить работу с Gradle и JDK без проблем совместимости." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673435411" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="9b67e5">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="9b67e5" />
              <option name="initiateTms" value="1729673610391" />
              <option name="request" value=" Вот это описание сделай короче&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, вот сокращенное описание:&#10;&#10;```java&#10;/**&#10; * Worker выполняет задачи из очереди до завершения пула.&#10; */&#10;```" />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673612401" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="a1ff85">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="a1ff85" />
              <option name="initiateTms" value="1729672193218" />
              <option name="request" value=" // Логирование или обработка исключения&#10;                    что здесь написать?" />
              <option name="response" value="" />
              <option name="responseDescription" value="Для логирования или обработки исключений в Java можно использовать различные подходы. Один из наиболее распространенных и рекомендуемых способов — использование библиотеки логирования, такой как `java.util.logging`, `Log4j`, или `SLF4J` с `Logback`.&#10;&#10;Для простоты, давайте используем `java.util.logging`, которая является частью стандартной библиотеки Java.&#10;&#10;### Worker.java с логированием&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.Queue;&#10;import java.util.logging.Level;&#10;import java.util.logging.Logger;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;public class Worker extends Thread {&#10;    private static final Logger logger = Logger.getLogger(Worker.class.getName());&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    /**&#10;     * Создает Worker с указанной очередью задач и пулом потоков.&#10;     *&#10;     * @param taskQueue очередь задач для выполнения&#10;     * @param threadPool пул потоков, к которому принадлежит этот рабочий поток&#10;     */&#10;    public Worker(Queue&lt;Runnable&gt; taskQueue, CustomThreadPool threadPool) {&#10;        this.taskQueue = taskQueue;&#10;        this.threadPool = threadPool;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    logger.log(Level.SEVERE, &quot;Ошибка при выполнении задачи&quot;, e);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение&#10;1. **Импорт библиотеки логирования**:&#10;    - Мы импортируем `java.util.logging.Logger` и `java.util.logging.Level`.&#10;&#10;2. **Создание логгера**:&#10;    - Создаем статический экземпляр `Logger` для класса `Worker`.&#10;&#10;3. **Логирование исключений**:&#10;    - В блоке `catch (RuntimeException e)` мы используем `logger.log(Level.SEVERE, &quot;Ошибка при выполнении задачи&quot;, e)` для логирования исключения с уровнем `SEVERE`.&#10;&#10;### Пример использования CustomThreadPool&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        CustomThreadPool threadPool = new CustomThreadPool(5);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int taskNumber = i;&#10;            threadPool.execute(() -&gt; {&#10;                System.out.println(&quot;Выполнение задачи &quot; + taskNumber + &quot; потоком &quot; + Thread.currentThread().getName());&#10;                try {&#10;                    Thread.sleep(1000); // Симуляция выполнения задачи&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                }&#10;            });&#10;        }&#10;&#10;        threadPool.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение кода&#10;1. **CustomThreadPool**:&#10;    - Конструктор принимает `capacity` (количество рабочих потоков) и инициализирует их.&#10;    - Метод `execute(Runnable task)` добавляет задачу в очередь задач и уведомляет один из потоков о наличии новой задачи.&#10;    - Метод `shutdown()` устанавливает флаг `isShutdown` в `true` и уведомляет все потоки, чтобы они могли завершить свою работу.&#10;    - Метод `isShutdown()` возвращает текущее состояние пула потоков.&#10;&#10;2. **Worker**:&#10;    - Класс `Worker` расширяет `Thread` и выполняет задачи из очереди.&#10;    - В методе `run()` поток ждет, пока в очереди появится задача, и выполняет её. Если пул завершен и очередь пуста, поток завершает свою работу.&#10;    - Исключения, возникающие при выполнении задач, логируются с использованием `Logger`.&#10;&#10;3. **Application**:&#10;    - Пример использования пула потоков. Создаются и добавляются задачи в пул, после чего пул завершается.&#10;&#10;Этот подход обеспечивает простое и эффективное логирование исключений, что помогает в отладке и мониторинге работы пула потоков." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672206370" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="a46b66">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="a46b66" />
              <option name="initiateTms" value="1729672068058" />
              <option name="request" value=" Описание на руссом" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, давайте добавим Javadoc комментарии на русском языке.&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Проверяет, завершен ли пул потоков.&#10;     *&#10;     * @return true, если пул потоков завершен, false в противном случае&#10;     */&#10;    public boolean isShutdown() {&#10;        return isShutdown;&#10;    }&#10;}&#10;```&#10;&#10;### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    /**&#10;     * Создает Worker с указанной очередью задач и пулом потоков.&#10;     *&#10;     * @param taskQueue очередь задач для выполнения&#10;     * @param threadPool пул потоков, к которому принадлежит этот рабочий поток&#10;     */&#10;    public Worker(Queue&lt;Runnable&gt; taskQueue, CustomThreadPool threadPool) {&#10;        this.taskQueue = taskQueue;&#10;        this.threadPool = threadPool;&#10;    }&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    // Логирование или обработка исключения&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Пример использования CustomThreadPool&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        CustomThreadPool threadPool = new CustomThreadPool(5);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int taskNumber = i;&#10;            threadPool.execute(() -&gt; {&#10;                System.out.println(&quot;Выполнение задачи &quot; + taskNumber + &quot; потоком &quot; + Thread.currentThread().getName());&#10;                try {&#10;                    Thread.sleep(1000); // Симуляция выполнения задачи&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                }&#10;            });&#10;        }&#10;&#10;        threadPool.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение кода&#10;1. **CustomThreadPool**:&#10;    - Конструктор принимает `capacity` (количество рабочих потоков) и инициализирует их.&#10;    - Метод `execute(Runnable task)` добавляет задачу в очередь задач и уведомляет один из потоков о наличии новой задачи.&#10;    - Метод `shutdown()` устанавливает флаг `isShutdown` в `true` и уведомляет все потоки, чтобы они могли завершить свою работу.&#10;    - Метод `isShutdown()` возвращает текущее состояние пула потоков.&#10;&#10;2. **Worker**:&#10;    - Класс `Worker` расширяет `Thread` и выполняет задачи из очереди.&#10;    - В методе `run()` поток ждет, пока в очереди появится задача, и выполняет её. Если пул завершен и очередь пуста, поток завершает свою работу.&#10;&#10;3. **Application**:&#10;    - Пример использования пула потоков. Создаются и добавляются задачи в пул, после чего пул завершается.&#10;&#10;Эта версия кода более структурирована и документирована, что делает её легче для понимания и сопровождения." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672086777" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="b6bfb7">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/streamapi/model/Task.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="b6bfb7" />
              <option name="initiateTms" value="1729672847970" />
              <option name="request" value=" * What went wrong:&#10;Execution failed for task ':compileJava'.&#10;&gt; java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'&#10;&#10;&#10;     * �?нициирует упорядоченное завершение работы пула потоков.&#10;        ^" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибка, которую вы видите, связана с несовместимостью между версиями Lombok и используемого компилятора Java. Это может произойти, если вы используете более новую версию Lombok с более старой версией JDK или наоборот.&#10;&#10;### Шаги для устранения ошибки&#10;&#10;1. **Проверьте версию JDK**:&#10;    - Убедитесь, что вы используете JDK версии 21.0.4, как указано в вашем запросе.&#10;&#10;2. **Обновите Lombok**:&#10;    - Убедитесь, что вы используете последнюю версию Lombok. На момент написания это версия 1.18.28.&#10;&#10;3. **Проверьте совместимость Lombok и JDK**:&#10;    - Убедитесь, что версия Lombok совместима с вашей версией JDK. Иногда могут быть проблемы совместимости, которые решаются в более новых версиях Lombok.&#10;&#10;### Обновление build.gradle&#10;Убедитесь, что ваш `build.gradle` файл выглядит следующим образом:&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Проверка конфигурации Lombok&#10;Убедитесь, что у вас установлены плагины Lombok в вашей IDE (например, IntelliJ IDEA или Eclipse). Это необходимо для правильной работы аннотаций Lombok.&#10;&#10;### Пример кода с Lombok&#10;Убедитесь, что ваш код использует правильные аннотации Lombok и не содержит ошибок:&#10;&#10;#### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.Getter;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;@Slf4j&#10;public class CustomThreadPool {&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    @Getter&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;#### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    log.error(&quot;Ошибка при выполнении задачи&quot;, e);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Проверка конфигурации IDE&#10;Убедитесь, что ваша IDE правильно настроена для работы с Lombok:&#10;- В IntelliJ IDEA: Убедитесь, что плагин Lombok установлен и включен. Перейдите в `File &gt; Settings &gt; Plugins` и найдите Lombok.&#10;- В Eclipse: Убедитесь, что плагин Lombok установлен. Перейдите в `Help &gt; Eclipse Marketplace` и найдите Lombok.&#10;&#10;Эти шаги должны помочь вам устранить ошибку и успешно скомпилировать ваш проект." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729672869230" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/streamapi/model/Task.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="cb960c">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                </list>
              </option>
              <option name="id" value="cb960c" />
              <option name="initiateTms" value="1729673018250" />
              <option name="request" value=" Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'" />
              <option name="response" value="" />
              <option name="responseDescription" value="Ошибка, которую вы видите, связана с несовместимостью между Lombok и используемым компилятором Java. Это может произойти, если вы используете более новую версию Lombok с более старой версией JDK или наоборот. Давайте попробуем несколько шагов для устранения этой проблемы.&#10;&#10;### Шаги для устранения ошибки&#10;&#10;1. **Проверьте версию JDK**:&#10;    - Убедитесь, что вы используете JDK версии 21.0.4, как указано в вашем запросе.&#10;&#10;2. **Обновите Lombok**:&#10;    - Убедитесь, что вы используете последнюю версию Lombok. На момент написания это версия 1.18.28.&#10;&#10;3. **Проверьте совместимость Lombok и JDK**:&#10;    - Убедитесь, что версия Lombok совместима с вашей версией JDK. Иногда могут быть проблемы совместимости, которые решаются в более новых версиях Lombok.&#10;&#10;### Обновление build.gradle&#10;Убедитесь, что ваш `build.gradle` файл выглядит следующим образом:&#10;&#10;```gradle&#10;plugins {&#10;    id 'java'&#10;}&#10;&#10;group = 'ru.otus.java.pro'&#10;version = '1.0-SNAPSHOT'&#10;&#10;repositories {&#10;    mavenCentral()&#10;}&#10;&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.28'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.28'&#10;    implementation 'org.slf4j:slf4j-api:2.0.7'&#10;    implementation 'ch.qos.logback:logback-classic:1.4.11'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.10.0'&#10;    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.10.0'&#10;    testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'&#10;    testImplementation 'org.mockito:mockito-core:5.11.0'&#10;    testImplementation 'org.mockito:mockito-junit-jupiter:5.11.0'&#10;}&#10;&#10;test {&#10;    useJUnitPlatform()&#10;}&#10;```&#10;&#10;### Проверка конфигурации Lombok&#10;Убедитесь, что у вас установлены плагины Lombok в вашей IDE (например, IntelliJ IDEA или Eclipse). Это необходимо для правильной работы аннотаций Lombok.&#10;&#10;### Пример кода с Lombok&#10;Убедитесь, что ваш код использует правильные аннотации Lombok и не содержит ошибок:&#10;&#10;#### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.Getter;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;/**&#10; * CustomThreadPool - это простая реализация пула потоков.&#10; * Он управляет фиксированным количеством рабочих потоков и очередью задач.&#10; * Задачи выполняются рабочими потоками по мере их доступности.&#10; */&#10;@Slf4j&#10;public class CustomThreadPool {&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    @Getter&#10;    private volatile boolean isShutdown;&#10;&#10;    /**&#10;     * Создает CustomThreadPool с указанным количеством рабочих потоков.&#10;     *&#10;     * @param capacity количество рабочих потоков в пуле&#10;     */&#10;    public CustomThreadPool(int capacity) {&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker(taskQueue, this);&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Добавляет задачу для выполнения в пул потоков.&#10;     *&#10;     * @param task задача для выполнения&#10;     * @throws IllegalStateException если пул потоков завершен&#10;     */&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;Пул потоков завершен, невозможно принять новые задачи&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Инициирует упорядоченное завершение работы пула потоков.&#10;     * Новые задачи не будут приниматься, и все рабочие потоки завершат работу&#10;     * после выполнения всех задач в очереди.&#10;     */&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;#### Worker.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import java.util.Queue;&#10;&#10;/**&#10; * Worker - это поток, который выполняет задачи из очереди задач.&#10; * Он является частью CustomThreadPool и будет продолжать работать до тех пор,&#10; * пока пул не будет завершен и очередь задач не станет пустой.&#10; */&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class Worker extends Thread {&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private final CustomThreadPool threadPool;&#10;&#10;    @Override&#10;    public void run() {&#10;        while (true) {&#10;            Runnable task;&#10;            synchronized (taskQueue) {&#10;                while (taskQueue.isEmpty() &amp;&amp; !threadPool.isShutdown()) {&#10;                    try {&#10;                        taskQueue.wait();&#10;                    } catch (InterruptedException e) {&#10;                        Thread.currentThread().interrupt();&#10;                        return;&#10;                    }&#10;                }&#10;                if (threadPool.isShutdown() &amp;&amp; taskQueue.isEmpty()) {&#10;                    return;&#10;                }&#10;                task = taskQueue.poll();&#10;            }&#10;            if (task != null) {&#10;                try {&#10;                    task.run();&#10;                } catch (RuntimeException e) {&#10;                    log.error(&quot;Ошибка при выполнении задачи&quot;, e);&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Проверка конфигурации IDE&#10;Убедитесь, что ваша IDE правильно настроена для работы с Lombok:&#10;- В IntelliJ IDEA: Убедитесь, что плагин Lombok установлен и включен. Перейдите в `File &gt; Settings &gt; Plugins` и найдите Lombok.&#10;- В Eclipse: Убедитесь, что плагин Lombok установлен. Перейдите в `Help &gt; Eclipse Marketplace` и найдите Lombok.&#10;&#10;### Альтернативное решение&#10;Если проблема не решается, попробуйте использовать более старую версию Lombok, которая может быть более совместимой с вашей версией JDK. Например, попробуйте версию 1.18.20:&#10;&#10;```gradle&#10;dependencies {&#10;    implementation 'org.projectlombok:lombok:1.18.20'&#10;    annotationProcessor 'org.projectlombok:lombok:1.18.20'&#10;    // остальные зависимости&#10;}&#10;```&#10;&#10;Эти шаги должны помочь вам устранить ошибку и успешно скомпилировать ваш проект." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673039825" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Worker.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="d18e52">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$USER_HOME$/.jdks/openjdk-22/lib/src.zip!/jdk.compiler/com/sun/tools/javac/tree/JCTree.java" />
                </list>
              </option>
              <option name="id" value="d18e52" />
              <option name="initiateTms" value="1729673105643" />
              <option name="request" value=" Execution failed for task ':compileJava'.&#10;&gt; java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'" />
              <option name="response" value="" />
              <option name="responseDescription" value="The error message `java.lang.NoSuchFieldError: Class com.sun.tools.javac.tree.JCTree$JCImport does not have member field 'com.sun.tools.javac.tree.JCTree qualid'` indicates that there is an issue with the field `qualid` in the `JCImport` class. Specifically, it suggests that the field `qualid` is either missing or incorrectly defined.&#10;&#10;Let's review the `JCImport` class definition to ensure that the `qualid` field is correctly defined and accessible.&#10;&#10;### Current `JCImport` Class Definition&#10;```java&#10;public static class JCImport extends JCTree implements ImportTree {&#10;    public boolean staticImport;&#10;    /** The imported class(es). */&#10;    public JCFieldAccess qualid;&#10;    public com.sun.tools.javac.code.Scope importScope;&#10;&#10;    protected JCImport(JCFieldAccess qualid, boolean importStatic) {&#10;        this.qualid = qualid;&#10;        this.staticImport = importStatic;&#10;    }&#10;&#10;    @Override&#10;    public void accept(Visitor v) { v.visitImport(this); }&#10;&#10;    @DefinedBy(Api.COMPILER_TREE)&#10;    public boolean isStatic() { return staticImport; }&#10;&#10;    @DefinedBy(Api.COMPILER_TREE)&#10;    public JCFieldAccess getQualifiedIdentifier() { return qualid; }&#10;&#10;    @DefinedBy(Api.COMPILER_TREE)&#10;    public Kind getKind() { return Kind.IMPORT; }&#10;&#10;    @Override @DefinedBy(Api.COMPILER_TREE)&#10;    public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {&#10;        return v.visitImport(this, d);&#10;    }&#10;&#10;    @Override&#10;    public Tag getTag() {&#10;        return IMPORT;&#10;    }&#10;}&#10;```&#10;&#10;### Analysis&#10;The `qualid` field is defined as `public JCFieldAccess qualid;`, which should be accessible. However, the error suggests that the field might not be found or accessible in the context where it is being used.&#10;&#10;### Potential Solutions&#10;1. **Ensure Correct Field Definition**: Verify that the `qualid` field is correctly defined as `public JCFieldAccess qualid;` and that there are no typos or visibility issues.&#10;&#10;2. **Check for Classpath Issues**: Ensure that there are no conflicting versions of the `JCTree` class in the classpath. Sometimes, having multiple versions of the same class can cause such issues.&#10;&#10;3. **Rebuild the Project**: Clean and rebuild the project to ensure that all classes are correctly compiled and there are no stale class files.&#10;&#10;4. **Check for Field Access**: Ensure that the field `qualid` is being accessed correctly in the code. If there are any reflective operations or other mechanisms that access this field, ensure they are correctly implemented.&#10;&#10;### Example Fix&#10;If the field `qualid` is correctly defined and the issue persists, you might want to check the usage of this field in the codebase. For example, if there is a reflective access, ensure it is correctly implemented:&#10;&#10;```java&#10;// Example of reflective access to the 'qualid' field&#10;try {&#10;    Field qualidField = JCImport.class.getDeclaredField(&quot;qualid&quot;);&#10;    qualidField.setAccessible(true);&#10;    JCFieldAccess qualidValue = (JCFieldAccess) qualidField.get(jcImportInstance);&#10;} catch (NoSuchFieldException | IllegalAccessException e) {&#10;    e.printStackTrace();&#10;}&#10;```&#10;&#10;### Conclusion&#10;The `qualid` field in the `JCImport` class appears to be correctly defined. The error might be due to classpath issues, incorrect field access, or stale class files. Ensure that the project is correctly built, and there are no conflicting versions of the `JCTree` class. If the issue persists, provide more context or specific code snippets where the error occurs for further analysis." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729673118753" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$USER_HOME$/.jdks/openjdk-22/lib/src.zip!/jdk.compiler/com/sun/tools/javac/tree/JCTree.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/streamapi/model/Task.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
        <entry key="d38453">
          <value>
            <ChatHistoryModel>
              <option name="contextFilesPaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
              <option name="id" value="d38453" />
              <option name="initiateTms" value="1729671918698" />
              <option name="request" value=" А если сделать реализацию попроще" />
              <option name="response" value="" />
              <option name="responseDescription" value="Конечно, можно упростить реализацию пула потоков, сохранив основные функциональные возможности. Вот более упрощенная версия:&#10;&#10;### CustomThreadPool.java&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;import java.util.LinkedList;&#10;import java.util.List;&#10;import java.util.Queue;&#10;&#10;public class CustomThreadPool {&#10;    private final int capacity;&#10;    private final List&lt;Worker&gt; workers;&#10;    private final Queue&lt;Runnable&gt; taskQueue;&#10;    private volatile boolean isShutdown;&#10;&#10;    public CustomThreadPool(int capacity) {&#10;        this.capacity = capacity;&#10;        this.taskQueue = new LinkedList&lt;&gt;();&#10;        this.workers = new LinkedList&lt;&gt;();&#10;        this.isShutdown = false;&#10;&#10;        for (int i = 0; i &lt; capacity; i++) {&#10;            Worker worker = new Worker();&#10;            workers.add(worker);&#10;            worker.start();&#10;        }&#10;    }&#10;&#10;    public void execute(Runnable task) {&#10;        if (isShutdown) {&#10;            throw new IllegalStateException(&quot;ThreadPool is shutdown, cannot accept new tasks&quot;);&#10;        }&#10;        synchronized (taskQueue) {&#10;            taskQueue.add(task);&#10;            taskQueue.notify();&#10;        }&#10;    }&#10;&#10;    public void shutdown() {&#10;        isShutdown = true;&#10;        synchronized (taskQueue) {&#10;            taskQueue.notifyAll();&#10;        }&#10;    }&#10;&#10;    private class Worker extends Thread {&#10;        @Override&#10;        public void run() {&#10;            while (true) {&#10;                Runnable task;&#10;                synchronized (taskQueue) {&#10;                    while (taskQueue.isEmpty() &amp;&amp; !isShutdown) {&#10;                        try {&#10;                            taskQueue.wait();&#10;                        } catch (InterruptedException e) {&#10;                            Thread.currentThread().interrupt();&#10;                            return;&#10;                        }&#10;                    }&#10;                    if (isShutdown &amp;&amp; taskQueue.isEmpty()) {&#10;                        return;&#10;                    }&#10;                    task = taskQueue.poll();&#10;                }&#10;                if (task != null) {&#10;                    try {&#10;                        task.run();&#10;                    } catch (RuntimeException e) {&#10;                        // Log or handle the exception&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### Пример использования CustomThreadPool&#10;```java&#10;package ru.otus.java.pro.concurrency;&#10;&#10;public class Application {&#10;    public static void main(String[] args) {&#10;        CustomThreadPool threadPool = new CustomThreadPool(5);&#10;&#10;        for (int i = 0; i &lt; 10; i++) {&#10;            int taskNumber = i;&#10;            threadPool.execute(() -&gt; {&#10;                System.out.println(&quot;Executing task &quot; + taskNumber + &quot; by &quot; + Thread.currentThread().getName());&#10;                try {&#10;                    Thread.sleep(1000); // Simulate task execution&#10;                } catch (InterruptedException e) {&#10;                    Thread.currentThread().interrupt();&#10;                }&#10;            });&#10;        }&#10;&#10;        threadPool.shutdown();&#10;    }&#10;}&#10;```&#10;&#10;### Объяснение упрощенного кода&#10;1. **CustomThreadPool**:&#10;    - Конструктор принимает `capacity` (количество рабочих потоков) и инициализирует их.&#10;    - Метод `execute(Runnable task)` добавляет задачу в очередь задач и уведомляет один из потоков о наличии новой задачи.&#10;    - Метод `shutdown()` устанавливает флаг `isShutdown` в `true` и уведомляет все потоки, чтобы они могли завершить свою работу.&#10;&#10;2. **Worker**:&#10;    - Класс `Worker` расширяет `Thread` и выполняет задачи из очереди.&#10;    - В методе `run()` поток ждет, пока в очереди появится задача, и выполняет её. Если пул завершен и очередь пуста, поток завершает свою работу.&#10;&#10;3. **Application**:&#10;    - Пример использования пула потоков. Создаются и добавляются задачи в пул, после чего пул завершается.&#10;&#10;Эта версия кода проще и легче для понимания, но все еще выполняет основные функции пула потоков." />
              <option name="responseFileName" value="" />
              <option name="responseFilePath" value="" />
              <option name="responseTms" value="1729671928977" />
              <option name="usedLocalFilePaths">
                <list>
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/Application.java" />
                  <option value="$PROJECT_DIR$/src/main/java/ru/otus/java/pro/concurrency/CustomThreadPool.java" />
                </list>
              </option>
            </ChatHistoryModel>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>